---
phase: 03-integration-and-results
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/generation.ts
  - src/constants/api.ts
  - src/constants/ui.ts
  - src/hooks/useGeneration.ts
  - src/components/generation/LoadingOverlay.tsx
autonomous: true

must_haves:
  truths:
    - "Loading overlay appears when generation starts"
    - "Progress stages show during wait (Siunčiama, Generuojama 1/3, etc.)"
    - "Cancel button stops generation and returns to idle"
    - "60-second timeout triggers error state"
  artifacts:
    - path: "src/types/generation.ts"
      provides: "Generation state and response types"
      exports: ["GenerationState", "GenerationProgress", "GeneratedImage", "GenerationResponse"]
    - path: "src/constants/api.ts"
      provides: "API endpoint and timeout configuration"
      exports: ["API_CONFIG"]
    - path: "src/hooks/useGeneration.ts"
      provides: "Generation state machine with abort/timeout"
      exports: ["useGeneration"]
    - path: "src/components/generation/LoadingOverlay.tsx"
      provides: "Full-screen loading with progress and cancel"
      exports: ["LoadingOverlay"]
  key_links:
    - from: "src/hooks/useGeneration.ts"
      to: "AbortSignal.timeout + AbortSignal.any"
      via: "fetch with combined signals"
      pattern: "AbortSignal\\.any"
    - from: "src/components/generation/LoadingOverlay.tsx"
      to: "src/hooks/useGeneration.ts"
      via: "onCancel callback"
      pattern: "onCancel"
---

<objective>
Create the generation hook with AbortController-based timeout/cancellation and the loading overlay component with progress stages.

Purpose: Enable the 30-60 second generation flow with proper user feedback, cancellation, and timeout handling as the foundation for Phase 3.

Output: Generation types, API config, useGeneration hook, LoadingOverlay component with Lithuanian progress messages.
</objective>

<execution_context>
@C:\Users\milos\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\milos\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-integration-and-results/03-CONTEXT.md
@.planning/phases/03-integration-and-results/03-RESEARCH.md
@src/types/index.ts
@src/constants/ui.ts
@src/hooks/useImageUpload.ts
@.env.local
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generation types and API constants</name>
  <files>src/types/generation.ts, src/constants/api.ts, src/constants/ui.ts</files>
  <action>
Create src/types/generation.ts with:
- GenerationProgress type: 'sending' | 'generating-1' | 'generating-2' | 'generating-3' | 'complete'
- GenerationState interface: { status: 'idle' | 'loading' | 'success' | 'error', progress: GenerationProgress, results: GeneratedImage[] | null, error: ErrorType | null }
- GeneratedImage interface: { url: string, angle: 'far' | 'medium' | 'close' }
- GenerationResponse interface: { success: boolean, images: GeneratedImage[] }
- ErrorType type: 'TIMEOUT' | 'NETWORK' | 'API_ERROR'

Create src/constants/api.ts with:
- API_CONFIG object: { webhookUrl: import.meta.env.VITE_N8N_WEBHOOK_URL, timeout: 60000 }
- Include fallback for missing env var (empty string, will fail gracefully)

Update src/constants/ui.ts to add:
- loading section: { sending: 'Siunčiama...', generating1: 'Generuojama 1/3...', generating2: 'Generuojama 2/3...', generating3: 'Beveik baigta...', complete: 'Baigta!' }
- tips array: ['Patarimas: Geriausi rezultatai su vienspalviais drabužiais', 'Patarimas: Aiškios nuotraukos duoda geriausius rezultatus', 'Patarimas: Vengti per daug priedų ar raštų']
- errors section: { timeout: 'Užtruko per ilgai. Bandykite dar kartą.', network: 'Patikrinkite interneto ryšį ir bandykite dar kartą.', api: 'Nepavyko sugeneruoti. Bandykite vėliau.', default: 'Įvyko klaida. Bandykite dar kartą.' }
- actions.cancel: 'Atšaukti'
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass with no type errors.
Verify files exist and export correct types.
  </verify>
  <done>
Generation types defined, API config reads from env, UI text includes all Lithuanian loading/error messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useGeneration hook</name>
  <files>src/hooks/useGeneration.ts</files>
  <action>
Create src/hooks/useGeneration.ts with:

1. Import types from generation.ts, API_CONFIG from api.ts
2. Use useRef for AbortController (new instance per request)
3. Use useState for GenerationState

4. generate() function:
   - Create new AbortController
   - Set state to loading/sending
   - Use AbortSignal.timeout(60000) for hard timeout
   - Use AbortSignal.any([controller.signal, timeoutSignal]) to combine
   - POST to webhookUrl with JSON body containing config and images (as base64)
   - Simulate progress stages with setTimeout (20s intervals): sending->generating-1->generating-2->generating-3
   - On success: set status='success', results=data.images
   - On TimeoutError: set error='TIMEOUT'
   - On AbortError: set status='idle' (user cancelled - silent)
   - On other error: set error='NETWORK' or 'API_ERROR'

5. cancel() function:
   - Call abortController.abort()
   - Reset state to idle

6. reset() function:
   - Reset state to idle

7. Cleanup on unmount: abort any pending request

Return: { state, generate, cancel, reset }

IMPORTANT: Use try/catch around fetch. Check err.name to distinguish TimeoutError vs AbortError vs other.
Do NOT use Promise.race - use AbortSignal.any (modern standard, 2023+).
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Check that hook exports { state, generate, cancel, reset }.
  </verify>
  <done>
useGeneration hook manages full generation lifecycle with abort/timeout, returns state and control functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create LoadingOverlay component</name>
  <files>src/components/generation/LoadingOverlay.tsx</files>
  <action>
Create src/components/generation/LoadingOverlay.tsx:

1. Props: { progress: GenerationProgress, onCancel: () => void }

2. Use UI_TEXT.loading for progress messages based on progress prop:
   - 'sending' -> UI_TEXT.loading.sending
   - 'generating-1' -> UI_TEXT.loading.generating1
   - 'generating-2' -> UI_TEXT.loading.generating2
   - 'generating-3' -> UI_TEXT.loading.generating3

3. Layout (per CONTEXT.md decisions):
   - Fixed full-screen overlay: fixed inset-0 z-50
   - Semi-transparent backdrop: bg-black/40 backdrop-blur-sm
   - Centered modal: flex items-center justify-center
   - White card: bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4

4. Content:
   - Indeterminate progress bar: <progress value={undefined} /> with Tailwind styling
   - Progress message: text-lg font-semibold text-center
   - Random tip from UI_TEXT.tips (pick one on mount using useState)
   - Cancel button: full-width, gray background, calls onCancel

5. Animation: Add subtle fade-in animation to modal (can use Tailwind animate utilities or inline style)

Use native HTML <progress> element (accessible, no JS bundle).
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Create a simple test render in console or storybook-like check.
  </verify>
  <done>
LoadingOverlay shows progress stages, tips, and cancel button with backdrop blur.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` passes
2. All files exist in correct locations
3. Types are properly exported and importable
4. Hook can be instantiated without errors
5. Component renders without runtime errors
</verification>

<success_criteria>
- GenerationState type defines complete state machine
- useGeneration hook handles generate/cancel/reset with proper AbortController usage
- LoadingOverlay shows Lithuanian progress messages
- 60-second timeout is enforced via AbortSignal.timeout
- All TypeScript types pass strict checking
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-and-results/03-01-SUMMARY.md`
</output>
