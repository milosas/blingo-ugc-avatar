{
  "name": "UGC Avatar Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-ugc",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "generate-ugc"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Avatar definitions (from src/constants/avatars.ts)\nconst AVATARS = {\n  'modern-city': {\n    description: 'Jauna moteris miesto aplinkoje, modernus ir profesionalus stilius, pasitikinti laikysena',\n    skinTone: 'light',\n    vibe: 'urban professional'\n  },\n  'elegant': {\n    description: 'Elegantiska moteris su subtilia estetika, idealiai tinka formaliems drabužiams',\n    skinTone: 'medium',\n    vibe: 'sophisticated elegance'\n  },\n  'sporty': {\n    description: 'Atletiska ir energinga moteris, puikiai tinka sportiniams ir casual drabužiams',\n    skinTone: 'light',\n    vibe: 'athletic dynamic'\n  },\n  'vintage-indie': {\n    description: 'Bohemisko stiliaus moteris su retro estetika, idealiai tinka vintage drabužiams',\n    skinTone: 'medium',\n    vibe: 'bohemian retro'\n  }\n};\n\n// Scene definitions (from src/constants/scenes.ts)\nconst SCENES = {\n  'studio': {\n    description: 'Baltas/pilkas fonas su profesionaliu apsvietimu'\n  },\n  'urban': {\n    description: 'Miesto aplinka su naturalia šviesa'\n  },\n  'minimal': {\n    description: 'Svarus fonas su zen estetika'\n  }\n};\n\n// Style definitions (from src/constants/styles.ts)\nconst STYLES = {\n  'casual': {\n    description: 'Kasdieniskas, patogus stilius'\n  },\n  'formal': {\n    description: 'Profesionalus, elegantiskas stilius'\n  },\n  'sporty': {\n    description: 'Atletiska, dinamiska estetika'\n  },\n  'vintage': {\n    description: 'Retro, bohemiska estetika'\n  }\n};\n\n// Get input from webhook\nconst input = $input.first().json;\nconst config = input.config;\n\n// Get selected avatar, scene, and style\nconst avatar = AVATARS[config.avatar];\nconst scene = SCENES[config.scene];\nconst style = STYLES[config.style];\n\n// Validate input\nif (!avatar || !scene || !style) {\n  throw new Error('Invalid configuration: avatar, scene, or style not found');\n}\n\n// Generate prompts for 3 camera angles\nconst prompts = [\n  {\n    angle: 'far',\n    prompt: `Full body shot of a ${avatar.description} wearing the clothing item.\nSetting: ${scene.description}.\nStyle: ${style.description}.\nVibe: ${avatar.vibe}.\nCamera angle: Wide shot from distance, showing full outfit from head to toe and surrounding environment.\nProfessional fashion photography, 1024x1792 portrait format, Instagram-ready, high quality, natural lighting, sharp focus on clothing details.\nModel pose: Standing confidently, full body visible.`\n  },\n  {\n    angle: 'close',\n    prompt: `Medium shot of a ${avatar.description} wearing the clothing item.\nSetting: ${scene.description}.\nStyle: ${style.description}.\nVibe: ${avatar.vibe}.\nCamera angle: Waist-up shot, focusing on upper body, torso, and clothing fit.\nProfessional fashion photography, 1024x1792 portrait format, Instagram-ready, high quality, natural lighting, sharp focus on fabric texture and clothing details.\nModel pose: Relaxed upper body pose, showing how the clothing fits.`\n  },\n  {\n    angle: 'veryClose',\n    prompt: `Close-up shot of a ${avatar.description} wearing the clothing item.\nSetting: ${scene.description}.\nStyle: ${style.description}.\nVibe: ${avatar.vibe}.\nCamera angle: Chest and face close-up, emphasizing fabric texture, clothing fit, and style details.\nProfessional fashion photography, 1024x1792 portrait format, Instagram-ready, high quality, natural lighting, sharp focus on clothing material and how it drapes.\nModel pose: Natural expression, showing clothing detail and fit on upper body.`\n  }\n];\n\n// Return array of prompts\nreturn prompts.map(p => ({ json: p }));"
      },
      "id": "generate-prompts",
      "name": "Generate Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {
          "reset": true
        }
      },
      "id": "split-in-batches",
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/images/generations",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "dall-e-3"
            },
            {
              "name": "prompt",
              "value": "={{ $json.prompt }}"
            },
            {
              "name": "size",
              "value": "1024x1792"
            },
            {
              "name": "quality",
              "value": "hd"
            },
            {
              "name": "n",
              "value": "1"
            }
          ]
        },
        "options": {
          "timeout": 45000,
          "response": {
            "response": {
              "responseFormat": "autodetect"
            }
          }
        }
      },
      "id": "openai-request",
      "name": "OpenAI Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "1",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Get all items from previous node (should be 3 OpenAI responses)\nconst items = $input.all();\n\n// Extract image data from each response\nconst images = items.map((item, index) => {\n  const data = item.json;\n\n  // OpenAI API response structure: data.data[0].url\n  const imageUrl = data.data?.[0]?.url;\n  const revisedPrompt = data.data?.[0]?.revised_prompt;\n\n  // Get angle from the original prompt data\n  const angles = ['far', 'close', 'veryClose'];\n  const angle = angles[index] || 'unknown';\n\n  return {\n    angle: angle,\n    url: imageUrl,\n    prompt: revisedPrompt || 'No prompt available'\n  };\n});\n\n// Create final response\nconst response = {\n  success: true,\n  images: images,\n  generatedAt: new Date().toISOString(),\n  count: images.length\n};\n\n// Return formatted response\nreturn [{ json: response }];"
      },
      "id": "format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1250, 300]
    },
    {
      "parameters": {},
      "id": "error-trigger",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [650, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Get error information\nconst error = $input.first().json;\n\n// Determine error type and create appropriate Lithuanian message\nlet errorCode = 'UNKNOWN_ERROR';\nlet errorMessage = 'Įvyko nežinoma klaida';\nlet errorDetails = '';\n\n// Check for specific error types\nif (error.message?.includes('API') || error.message?.includes('request')) {\n  errorCode = 'API_ERROR';\n  errorMessage = 'Nepavyko susisiekti su AI generavimo paslauga';\n  errorDetails = 'Patikrinkite API rakto galiojimą ir tinklo ryšį';\n} else if (error.message?.includes('timeout')) {\n  errorCode = 'TIMEOUT_ERROR';\n  errorMessage = 'Generavimas užtruko per ilgai';\n  errorDetails = 'Bandykite dar kartą. Jei problema kartojasi, susisiekite su administratoriumi';\n} else if (error.message?.includes('rate limit')) {\n  errorCode = 'RATE_LIMIT';\n  errorMessage = 'Viršytas API užklausų limitas';\n  errorDetails = 'Palaukite kelias minutes ir bandykite dar kartą';\n} else if (error.message?.includes('Invalid configuration')) {\n  errorCode = 'INVALID_CONFIG';\n  errorMessage = 'Neteisingi nustatymai';\n  errorDetails = 'Patikrinkite pasirinkto avataro, scenos ir stiliaus duomenis';\n} else {\n  // Generic error\n  errorCode = 'GENERATION_FAILED';\n  errorMessage = 'Nepavyko sugeneruoti nuotraukų';\n  errorDetails = error.message || 'Bandykite dar kartą';\n}\n\n// Create error response\nconst errorResponse = {\n  success: false,\n  error: {\n    code: errorCode,\n    message: errorMessage,\n    details: errorDetails,\n    timestamp: new Date().toISOString()\n  }\n};\n\n// Log error for debugging\nconsole.error('Workflow Error:', {\n  code: errorCode,\n  originalError: error.message,\n  timestamp: new Date().toISOString()\n});\n\n// Return error response\nreturn [{ json: errorResponse }];"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "respond-error",
      "name": "Respond with Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1050, 500]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Generate Prompts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Prompts": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split In Batches": {
      "main": [
        [
          {
            "node": "OpenAI Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Request": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Trigger": {
      "main": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Respond with Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-24T00:00:00.000Z",
  "versionId": "1"
}
